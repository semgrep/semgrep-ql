(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_ql"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "line_comment";
  "block_comment";
]

let children_regexps : (string * Run.exp option) list = [
  "float", None;
  "result", None;
  "semgrep_ellipsis_metavar", None;
  "true", None;
  "closure",
  Some (
    Alt [|
      Token (Literal "*");
      Token (Literal "+");
    |];
  );
  "compop",
  Some (
    Alt [|
      Token (Literal "=");
      Token (Literal "!=");
      Token (Literal "<");
      Token (Literal ">");
      Token (Literal "<=");
      Token (Literal ">=");
    |];
  );
  "primitivetype",
  Some (
    Alt [|
      Token (Literal "boolean");
      Token (Literal "date");
      Token (Literal "float");
      Token (Literal "int");
      Token (Literal "string");
    |];
  );
  "semgrep_metavariable", None;
  "addop",
  Some (
    Alt [|
      Token (Literal "+");
      Token (Literal "-");
    |];
  );
  "false", None;
  "direction",
  Some (
    Alt [|
      Token (Literal "asc");
      Token (Literal "desc");
    |];
  );
  "specialid", None;
  "semgrep_ellipsis", None;
  "super", None;
  "this", None;
  "string", None;
  "quantifier",
  Some (
    Alt [|
      Token (Literal "exists");
      Token (Literal "forall");
      Token (Literal "forex");
    |];
  );
  "empty", None;
  "underscore", None;
  "qldoc", None;
  "lower_id", None;
  "pat_3bf1220", None;
  "predicate", None;
  "mulop",
  Some (
    Alt [|
      Token (Literal "*");
      Token (Literal "/");
      Token (Literal "%");
    |];
  );
  "unop",
  Some (
    Alt [|
      Token (Literal "+");
      Token (Literal "-");
    |];
  );
  "integer", None;
  "dbtype", None;
  "aggid",
  Some (
    Alt [|
      Token (Name "semgrep_metavariable");
      Token (Literal "avg");
      Token (Literal "concat");
      Token (Literal "strictconcat");
      Token (Literal "count");
      Token (Literal "max");
      Token (Literal "min");
      Token (Literal "rank");
      Token (Literal "strictcount");
      Token (Literal "strictsum");
      Token (Literal "sum");
      Token (Literal "any");
      Token (Literal "unique");
    |];
  );
  "bool",
  Some (
    Alt [|
      Token (Name "true");
      Token (Name "false");
    |];
  );
  "special_call",
  Some (
    Seq [
      Token (Name "specialid");
      Token (Literal "(");
      Token (Literal ")");
    ];
  );
  "predicatename",
  Some (
    Alt [|
      Token (Name "lower_id");
      Token (Name "semgrep_metavariable");
    |];
  );
  "annotname",
  Some (
    Alt [|
      Token (Name "lower_id");
      Token (Name "semgrep_metavariable");
    |];
  );
  "upper_id",
  Some (
    Alt [|
      Token (Name "pat_3bf1220");
      Token (Name "semgrep_metavariable");
    |];
  );
  "literal",
  Some (
    Alt [|
      Token (Name "integer");
      Token (Name "float");
      Token (Name "bool");
      Token (Name "string");
    |];
  );
  "classname", Some (Token (Name "upper_id"););
  "literalid",
  Some (
    Alt [|
      Token (Name "lower_id");
      Token (Name "upper_id");
    |];
  );
  "simpleid",
  Some (
    Alt [|
      Token (Name "lower_id");
      Token (Name "upper_id");
    |];
  );
  "varname", Some (Token (Name "simpleid"););
  "annotarg",
  Some (
    Alt [|
      Token (Name "simpleid");
      Token (Name "this");
      Token (Name "result");
    |];
  );
  "modulename", Some (Token (Name "simpleid"););
  "variable",
  Some (
    Alt [|
      Token (Name "this");
      Token (Name "result");
      Token (Name "varname");
    |];
  );
  "annotation",
  Some (
    Alt [|
      Token (Name "annotname");
      Seq [
        Token (Name "annotname");
        Token (Literal "[");
        Token (Name "annotarg");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "annotarg");
          ];
        );
        Token (Literal "]");
      ];
    |];
  );
  "aritylesspredicateexpr",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Name "moduleexpr");
          Token (Literal "::");
        ];
      );
      Token (Name "literalid");
    ];
  );
  "moduleexpr",
  Some (
    Alt [|
      Token (Name "simpleid");
      Token (Name "moduleinstantiation");
      Seq [
        Token (Name "moduleexpr");
        Token (Literal "::");
        Alt [|
          Token (Name "simpleid");
          Token (Name "moduleinstantiation");
        |];
      ];
    |];
  );
  "moduleinstantiation",
  Some (
    Seq [
      Token (Name "modulename");
      Token (Literal "<");
      Token (Name "signatureexpr");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "signatureexpr");
        ];
      );
      Token (Literal ">");
    ];
  );
  "predicateexpr",
  Some (
    Seq [
      Token (Name "aritylesspredicateexpr");
      Token (Literal "/");
      Token (Name "integer");
    ];
  );
  "signatureexpr",
  Some (
    Alt [|
      Token (Name "typeexpr");
      Token (Name "moduleexpr");
      Token (Name "predicateexpr");
    |];
  );
  "typeexpr",
  Some (
    Alt [|
      Seq [
        Opt (
          Seq [
            Token (Name "moduleexpr");
            Token (Literal "::");
          ];
        );
        Token (Name "classname");
      ];
      Token (Name "dbtype");
      Token (Name "primitivetype");
    |];
  );
  "modulealiasbody",
  Some (
    Seq [
      Token (Literal "=");
      Token (Name "moduleexpr");
      Token (Literal ";");
    ];
  );
  "vardecl",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Seq [
        Token (Name "typeexpr");
        Token (Name "varname");
      ];
    |];
  );
  "typealiasbody",
  Some (
    Seq [
      Token (Literal "=");
      Token (Name "typeexpr");
      Token (Literal ";");
    ];
  );
  "super_ref",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Name "typeexpr");
          Token (Literal ".");
        ];
      );
      Token (Name "super");
    ];
  );
  "moduleparam",
  Some (
    Seq [
      Token (Name "signatureexpr");
      Token (Name "simpleid");
    ];
  );
  "importmoduleexpr",
  Some (
    Seq [
      Repeat (
        Seq [
          Token (Name "simpleid");
          Token (Literal ".");
        ];
      );
      Token (Name "moduleexpr");
    ];
  );
  "typeunionbody",
  Some (
    Seq [
      Token (Literal "=");
      Token (Name "typeexpr");
      Token (Literal "or");
      Opt (
        Seq [
          Token (Name "typeexpr");
          Repeat (
            Seq [
              Token (Literal "or");
              Token (Name "typeexpr");
            ];
          );
        ];
      );
      Token (Literal ";");
    ];
  );
  "predicatealiasbody",
  Some (
    Seq [
      Token (Literal "=");
      Token (Name "predicateexpr");
      Token (Literal ";");
    ];
  );
  "field",
  Some (
    Seq [
      Token (Name "vardecl");
      Token (Literal ";");
    ];
  );
  "add_expr",
  Some (
    Seq [
      Token (Name "exprorterm");
      Token (Name "addop");
      Token (Name "exprorterm");
    ];
  );
  "aggregate",
  Some (
    Seq [
      Token (Name "aggid");
      Opt (
        Seq [
          Token (Literal "[");
          Token (Name "exprorterm");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "exprorterm");
            ];
          );
          Token (Literal "]");
        ];
      );
      Token (Literal "(");
      Opt (
        Alt [|
          Token (Name "full_aggregate_body");
          Token (Name "expr_aggregate_body");
        |];
      );
      Token (Literal ")");
    ];
  );
  "asexpr",
  Some (
    Seq [
      Token (Name "exprorterm");
      Opt (
        Seq [
          Token (Literal "as");
          Token (Name "varname");
        ];
      );
    ];
  );
  "asexprs",
  Some (
    Seq [
      Token (Name "asexpr");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "asexpr");
        ];
      );
    ];
  );
  "call_arg",
  Some (
    Alt [|
      Token (Name "exprorterm");
      Token (Name "underscore");
    |];
  );
  "call_body",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "call_arg");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "call_arg");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "call_or_unqual_agg_body",
  Some (
    Alt [|
      Token (Name "call_body");
      Token (Name "unqual_agg_body");
    |];
  );
  "call_or_unqual_agg_expr",
  Some (
    Seq [
      Token (Name "aritylesspredicateexpr");
      Opt (
        Token (Name "closure");
      );
      Token (Name "call_or_unqual_agg_body");
    ];
  );
  "comp_term",
  Some (
    Seq [
      Token (Name "exprorterm");
      Token (Name "compop");
      Token (Name "exprorterm");
    ];
  );
  "conjunction",
  Some (
    Seq [
      Token (Name "exprorterm");
      Token (Literal "and");
      Token (Name "exprorterm");
    ];
  );
  "disjunction",
  Some (
    Seq [
      Token (Name "exprorterm");
      Token (Literal "or");
      Token (Name "exprorterm");
    ];
  );
  "expr_aggregate_body",
  Some (
    Seq [
      Token (Name "asexprs");
      Opt (
        Token (Name "orderbys");
      );
    ];
  );
  "expr_annotation",
  Some (
    Seq [
      Token (Name "annotname");
      Token (Literal "[");
      Token (Name "annotname");
      Token (Literal "]");
      Token (Literal "(");
      Token (Name "exprorterm");
      Token (Literal ")");
    ];
  );
  "exprorterm",
  Some (
    Alt [|
      Token (Name "special_call");
      Token (Name "prefix_cast");
      Token (Name "primary");
      Token (Name "unary_expr");
      Token (Name "mul_expr");
      Token (Name "add_expr");
      Token (Name "in_expr");
      Token (Name "comp_term");
      Token (Name "instance_of");
      Token (Name "negation");
      Token (Name "if_term");
      Token (Name "conjunction");
      Token (Name "disjunction");
      Token (Name "implication");
      Token (Name "quantified");
    |];
  );
  "full_aggregate_body",
  Some (
    Alt [|
      Seq [
        Opt (
          Seq [
            Token (Name "vardecl");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "vardecl");
              ];
            );
          ];
        );
        Token (Literal "|");
        Opt (
          Token (Name "exprorterm");
        );
        Opt (
          Seq [
            Token (Literal "|");
            Token (Name "asexprs");
            Opt (
              Token (Name "orderbys");
            );
          ];
        );
      ];
      Seq [
        Token (Name "vardecl");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "vardecl");
          ];
        );
      ];
    |];
  );
  "if_term",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "exprorterm");
      Token (Literal "then");
      Token (Name "exprorterm");
      Token (Literal "else");
      Token (Name "exprorterm");
    ];
  );
  "implication",
  Some (
    Seq [
      Token (Name "exprorterm");
      Token (Literal "implies");
      Token (Name "exprorterm");
    ];
  );
  "in_expr",
  Some (
    Seq [
      Token (Name "exprorterm");
      Token (Literal "in");
      Token (Name "primary");
    ];
  );
  "instance_of",
  Some (
    Seq [
      Token (Name "exprorterm");
      Token (Literal "instanceof");
      Token (Name "typeexpr");
    ];
  );
  "mul_expr",
  Some (
    Seq [
      Token (Name "exprorterm");
      Token (Name "mulop");
      Token (Name "exprorterm");
    ];
  );
  "negation",
  Some (
    Seq [
      Token (Literal "not");
      Token (Name "exprorterm");
    ];
  );
  "orderby",
  Some (
    Seq [
      Token (Name "exprorterm");
      Opt (
        Token (Name "direction");
      );
    ];
  );
  "orderbys",
  Some (
    Seq [
      Token (Literal "order");
      Token (Literal "by");
      Token (Name "orderby");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "orderby");
        ];
      );
    ];
  );
  "par_expr",
  Some (
    Alt [|
      Seq [
        Token (Literal "(");
        Token (Name "simpleid");
        Token (Name "semgrep_metavariable");
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "exprorterm");
        Token (Literal ")");
      ];
    |];
  );
  "prefix_cast",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "typeexpr");
      Token (Literal ")");
      Token (Name "exprorterm");
    ];
  );
  "primary",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Token (Name "semgrep_ellipsis_metavar");
      Token (Name "call_or_unqual_agg_expr");
      Token (Name "qualified_expr");
      Token (Name "literal");
      Token (Name "variable");
      Token (Name "super_ref");
      Token (Name "aggregate");
      Token (Name "range");
      Token (Name "set_literal");
      Token (Name "par_expr");
      Token (Name "expr_annotation");
    |];
  );
  "qualified_expr",
  Some (
    Seq [
      Token (Name "primary");
      Token (Literal ".");
      Token (Name "qualifiedrhs");
    ];
  );
  "qualifiedrhs",
  Some (
    Alt [|
      Seq [
        Token (Name "predicatename");
        Opt (
          Token (Name "closure");
        );
        Token (Literal "(");
        Opt (
          Seq [
            Token (Name "call_arg");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "call_arg");
              ];
            );
          ];
        );
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "typeexpr");
        Token (Literal ")");
      ];
    |];
  );
  "quantified",
  Some (
    Seq [
      Token (Name "quantifier");
      Token (Literal "(");
      Alt [|
        Seq [
          Opt (
            Seq [
              Token (Name "vardecl");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "vardecl");
                ];
              );
            ];
          );
          Opt (
            Seq [
              Token (Literal "|");
              Token (Name "exprorterm");
              Opt (
                Seq [
                  Token (Literal "|");
                  Token (Name "exprorterm");
                ];
              );
            ];
          );
        ];
        Token (Name "exprorterm");
      |];
      Token (Literal ")");
    ];
  );
  "range",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "exprorterm");
      Token (Literal "..");
      Token (Name "exprorterm");
      Token (Literal "]");
    ];
  );
  "set_literal",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "exprorterm");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "exprorterm");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "unary_expr",
  Some (
    Seq [
      Token (Name "unop");
      Token (Name "exprorterm");
    ];
  );
  "unqual_agg_body",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "vardecl");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "vardecl");
            ];
          );
        ];
      );
      Token (Literal "|");
      Opt (
        Token (Name "exprorterm");
      );
      Opt (
        Seq [
          Token (Literal "|");
          Token (Name "asexprs");
        ];
      );
      Token (Literal ")");
    ];
  );
  "importdirective",
  Some (
    Seq [
      Token (Literal "import");
      Token (Name "importmoduleexpr");
      Opt (
        Seq [
          Token (Literal "as");
          Token (Name "modulename");
        ];
      );
    ];
  );
  "select",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Literal "from");
          Opt (
            Seq [
              Token (Name "vardecl");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "vardecl");
                ];
              );
            ];
          );
        ];
      );
      Opt (
        Seq [
          Token (Literal "where");
          Token (Name "exprorterm");
        ];
      );
      Token (Literal "select");
      Token (Name "asexprs");
      Opt (
        Token (Name "orderbys");
      );
    ];
  );
  "body",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "exprorterm");
      Token (Literal "}");
    ];
  );
  "higherorderterm",
  Some (
    Seq [
      Token (Literal "=");
      Token (Name "literalid");
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "predicateexpr");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "predicateexpr");
            ];
          );
        ];
      );
      Token (Literal ")");
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "call_arg");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "call_arg");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "semgrep_expression",
  Some (
    Seq [
      Token (Literal "__SEMGREP_EXPRESSION");
      Token (Name "exprorterm");
    ];
  );
  "charpred",
  Some (
    Seq [
      Token (Name "classname");
      Token (Literal "(");
      Token (Literal ")");
      Token (Literal "{");
      Token (Name "exprorterm");
      Token (Literal "}");
    ];
  );
  "datatypebranch",
  Some (
    Seq [
      Opt (
        Token (Name "qldoc");
      );
      Opt (
        Token (Name "annotation");
      );
      Token (Name "classname");
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "vardecl");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "vardecl");
            ];
          );
        ];
      );
      Token (Literal ")");
      Opt (
        Token (Name "body");
      );
    ];
  );
  "optbody",
  Some (
    Alt [|
      Token (Name "empty");
      Token (Name "body");
      Token (Name "higherorderterm");
    |];
  );
  "datatypebranches",
  Some (
    Seq [
      Token (Name "datatypebranch");
      Repeat (
        Seq [
          Token (Literal "or");
          Token (Name "datatypebranch");
        ];
      );
    ];
  );
  "classlesspredicate",
  Some (
    Seq [
      Alt [|
        Token (Name "predicate");
        Token (Name "typeexpr");
      |];
      Token (Name "predicatename");
      Alt [|
        Seq [
          Token (Literal "(");
          Opt (
            Seq [
              Token (Name "vardecl");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "vardecl");
                ];
              );
            ];
          );
          Token (Literal ")");
          Token (Name "optbody");
        ];
        Token (Name "predicatealiasbody");
      |];
    ];
  );
  "memberpredicate",
  Some (
    Seq [
      Alt [|
        Token (Name "predicate");
        Token (Name "typeexpr");
      |];
      Token (Name "predicatename");
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "vardecl");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "vardecl");
            ];
          );
        ];
      );
      Token (Literal ")");
      Token (Name "optbody");
    ];
  );
  "datatype",
  Some (
    Seq [
      Token (Literal "newtype");
      Token (Name "classname");
      Token (Literal "=");
      Token (Name "datatypebranches");
    ];
  );
  "classmember",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Seq [
        Repeat (
          Token (Name "annotation");
        );
        Alt [|
          Token (Name "charpred");
          Token (Name "memberpredicate");
          Token (Name "field");
        |];
      ];
      Token (Name "qldoc");
    |];
  );
  "dataclass",
  Some (
    Seq [
      Token (Literal "class");
      Token (Name "classname");
      Alt [|
        Seq [
          Opt (
            Seq [
              Token (Literal "extends");
              Token (Name "typeexpr");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "typeexpr");
                ];
              );
            ];
          );
          Opt (
            Seq [
              Token (Literal "instanceof");
              Token (Name "typeexpr");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "typeexpr");
                ];
              );
            ];
          );
          Alt [|
            Seq [
              Token (Literal "{");
              Repeat (
                Token (Name "classmember");
              );
              Token (Literal "}");
            ];
            Token (Literal ";");
          |];
        ];
        Token (Name "typealiasbody");
        Token (Name "typeunionbody");
      |];
    ];
  );
  "module",
  Some (
    Seq [
      Token (Literal "module");
      Token (Name "modulename");
      Opt (
        Seq [
          Token (Literal "<");
          Token (Name "moduleparam");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "moduleparam");
            ];
          );
          Token (Literal ">");
        ];
      );
      Opt (
        Seq [
          Token (Literal "implements");
          Token (Name "signatureexpr");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "signatureexpr");
            ];
          );
        ];
      );
      Alt [|
        Seq [
          Token (Literal "{");
          Repeat (
            Token (Name "modulemember");
          );
          Token (Literal "}");
        ];
        Token (Name "modulealiasbody");
      |];
    ];
  );
  "modulemember",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Seq [
        Repeat (
          Token (Name "annotation");
        );
        Alt [|
          Token (Name "importdirective");
          Token (Name "classlesspredicate");
          Token (Name "dataclass");
          Token (Name "datatype");
          Token (Name "select");
          Token (Name "module");
        |];
      ];
      Token (Name "qldoc");
    |];
  );
  "ql",
  Some (
    Alt [|
      Token (Name "semgrep_expression");
      Repeat (
        Token (Name "modulemember");
      );
    |];
  );
]

let trans_float_ ((kind, body) : mt) : CST.float_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_result ((kind, body) : mt) : CST.result =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_ellipsis_metavar ((kind, body) : mt) : CST.semgrep_ellipsis_metavar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_closure ((kind, body) : mt) : CST.closure =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `PLUS (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_compop ((kind, body) : mt) : CST.compop =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `EQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `BANGEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `LT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `GT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `LTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `GTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_primitivetype ((kind, body) : mt) : CST.primitivetype =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bool (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Date (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Float (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Int (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Str (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semgrep_metavariable ((kind, body) : mt) : CST.semgrep_metavariable =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_addop ((kind, body) : mt) : CST.addop =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `PLUS (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DASH (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_direction ((kind, body) : mt) : CST.direction =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Asc (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Desc (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_specialid ((kind, body) : mt) : CST.specialid =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_ellipsis ((kind, body) : mt) : CST.semgrep_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_super ((kind, body) : mt) : CST.super =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_this ((kind, body) : mt) : CST.this =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_ ((kind, body) : mt) : CST.string_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_quantifier ((kind, body) : mt) : CST.quantifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exists (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Forall (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Forex (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_empty ((kind, body) : mt) : CST.empty =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_underscore ((kind, body) : mt) : CST.underscore =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_qldoc ((kind, body) : mt) : CST.qldoc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_lower_id ((kind, body) : mt) : CST.lower_id =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_3bf1220 ((kind, body) : mt) : CST.pat_3bf1220 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_predicate ((kind, body) : mt) : CST.predicate =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_mulop ((kind, body) : mt) : CST.mulop =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `SLASH (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `PERC (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_unop ((kind, body) : mt) : CST.unop =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `PLUS (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DASH (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_integer ((kind, body) : mt) : CST.integer =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_dbtype ((kind, body) : mt) : CST.dbtype =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_aggid ((kind, body) : mt) : CST.aggid =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_meta (
            trans_semgrep_metavariable (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Avg (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Concat (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Stri_18c266c (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Count (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Max (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Min (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Rank (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Stri_8bc2381 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Stri_a43e15b (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Sum (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Any (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Unique (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_bool_ ((kind, body) : mt) : CST.bool_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            trans_true_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            trans_false_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_special_call ((kind, body) : mt) : CST.special_call =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_specialid (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_predicatename ((kind, body) : mt) : CST.predicatename =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lower_id (
            trans_lower_id (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Semg_meta (
            trans_semgrep_metavariable (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_annotname ((kind, body) : mt) : CST.annotname =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lower_id (
            trans_lower_id (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Semg_meta (
            trans_semgrep_metavariable (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_upper_id ((kind, body) : mt) : CST.upper_id =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_3bf1220 (
            trans_pat_3bf1220 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Semg_meta (
            trans_semgrep_metavariable (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Int (
            trans_integer (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Float (
            trans_float_ (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Bool (
            trans_bool_ (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Str (
            trans_string_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_classname ((kind, body) : mt) : CST.classname =
  match body with
  | Children v ->
      trans_upper_id (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_literalid ((kind, body) : mt) : CST.literalid =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lower_id (
            trans_lower_id (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Upper_id (
            trans_upper_id (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_simpleid ((kind, body) : mt) : CST.simpleid =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lower_id (
            trans_lower_id (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Upper_id (
            trans_upper_id (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_varname ((kind, body) : mt) : CST.varname =
  match body with
  | Children v ->
      trans_simpleid (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_annotarg ((kind, body) : mt) : CST.annotarg =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Simp (
            trans_simpleid (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `This (
            trans_this (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Result (
            trans_result (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_modulename ((kind, body) : mt) : CST.modulename =
  match body with
  | Children v ->
      trans_simpleid (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_variable ((kind, body) : mt) : CST.variable =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `This (
            trans_this (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Result (
            trans_result (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Varn (
            trans_varname (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_annotation ((kind, body) : mt) : CST.annotation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Anno (
            trans_annotname (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Anno_LBRACK_anno_rep_COMMA_anno_RBRACK (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_annotname (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_annotarg (Run.matcher_token v2),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_annotarg (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_aritylesspredicateexpr ((kind, body) : mt) : CST.aritylesspredicateexpr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_moduleexpr (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_literalid (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_moduleexpr ((kind, body) : mt) : CST.moduleexpr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Simp (
            trans_simpleid (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Modu (
            trans_moduleinstantiation (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Modu_COLONCOLON_choice_simp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_moduleexpr (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  (match v2 with
                  | Alt (0, v) ->
                      `Simp (
                        trans_simpleid (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Modu (
                        trans_moduleinstantiation (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_moduleinstantiation ((kind, body) : mt) : CST.moduleinstantiation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_modulename (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_signatureexpr (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_signatureexpr (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_predicateexpr ((kind, body) : mt) : CST.predicateexpr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_aritylesspredicateexpr (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_integer (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_signatureexpr ((kind, body) : mt) : CST.signatureexpr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type (
            trans_typeexpr (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Modu (
            trans_moduleexpr (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pred (
            trans_predicateexpr (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_typeexpr ((kind, body) : mt) : CST.typeexpr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_modu_COLONCOLON_clas (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_moduleexpr (Run.matcher_token v0),
                            Run.trans_token (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v0
                  ,
                  trans_classname (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Dbtype (
            trans_dbtype (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Prim (
            trans_primitivetype (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_modulealiasbody ((kind, body) : mt) : CST.modulealiasbody =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_moduleexpr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_vardecl ((kind, body) : mt) : CST.vardecl =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type_varn (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_typeexpr (Run.matcher_token v0),
                  trans_varname (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_typealiasbody ((kind, body) : mt) : CST.typealiasbody =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_typeexpr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_super_ref ((kind, body) : mt) : CST.super_ref =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_typeexpr (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_super (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_moduleparam ((kind, body) : mt) : CST.moduleparam =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_signatureexpr (Run.matcher_token v0),
            trans_simpleid (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_importmoduleexpr ((kind, body) : mt) : CST.importmoduleexpr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_simpleid (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_moduleexpr (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_typeunionbody ((kind, body) : mt) : CST.typeunionbody =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_typeexpr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_typeexpr (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_typeexpr (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_predicatealiasbody ((kind, body) : mt) : CST.predicatealiasbody =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_predicateexpr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_field ((kind, body) : mt) : CST.field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_vardecl (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_add_expr ((kind, body) : mt) : CST.add_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            trans_addop (Run.matcher_token v1),
            trans_exprorterm (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_aggregate ((kind, body) : mt) : CST.aggregate =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_aggid (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_exprorterm (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_exprorterm (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.trans_token (Run.matcher_token v3)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Full_aggr_body (
                      trans_full_aggregate_body (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Expr_aggr_body (
                      trans_expr_aggregate_body (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_asexpr ((kind, body) : mt) : CST.asexpr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_varname (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_asexprs ((kind, body) : mt) : CST.asexprs =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_asexpr (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_asexpr (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_arg ((kind, body) : mt) : CST.call_arg =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Expr (
            trans_exprorterm (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Unde (
            trans_underscore (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_body ((kind, body) : mt) : CST.call_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_call_arg (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_call_arg (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_or_unqual_agg_body ((kind, body) : mt) : CST.call_or_unqual_agg_body =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Call_body (
            trans_call_body (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Unqual_agg_body (
            trans_unqual_agg_body (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_or_unqual_agg_expr ((kind, body) : mt) : CST.call_or_unqual_agg_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_aritylesspredicateexpr (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_closure (Run.matcher_token v))
              v1
            ,
            trans_call_or_unqual_agg_body (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_comp_term ((kind, body) : mt) : CST.comp_term =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            trans_compop (Run.matcher_token v1),
            trans_exprorterm (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_conjunction ((kind, body) : mt) : CST.conjunction =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_exprorterm (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_disjunction ((kind, body) : mt) : CST.disjunction =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_exprorterm (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expr_aggregate_body ((kind, body) : mt) : CST.expr_aggregate_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_asexprs (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_orderbys (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expr_annotation ((kind, body) : mt) : CST.expr_annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            trans_annotname (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_annotname (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_exprorterm (Run.matcher_token v5),
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exprorterm ((kind, body) : mt) : CST.exprorterm =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Spec_call (
            trans_special_call (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Prefix_cast (
            trans_prefix_cast (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Prim (
            trans_primary (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Un_expr (
            trans_unary_expr (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Mul_expr (
            trans_mul_expr (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Add_expr (
            trans_add_expr (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `In_expr (
            trans_in_expr (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Comp_term (
            trans_comp_term (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Inst_of (
            trans_instance_of (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Nega (
            trans_negation (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `If_term (
            trans_if_term (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Conj (
            trans_conjunction (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Disj (
            trans_disjunction (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Impl (
            trans_implication (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Quan (
            trans_quantified (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_full_aggregate_body ((kind, body) : mt) : CST.full_aggregate_body =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_vard_rep_COMMA_vard_BAR_opt_expr_opt_BAR_asexprs_opt_orders (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_vardecl (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_vardecl (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v0
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_exprorterm (Run.matcher_token v))
                    v2
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_asexprs (Run.matcher_token v1),
                            Run.opt
                              (fun v -> trans_orderbys (Run.matcher_token v))
                              v2
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Vard_rep_COMMA_vard (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_vardecl (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_vardecl (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_term ((kind, body) : mt) : CST.if_term =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exprorterm (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_exprorterm (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_exprorterm (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_implication ((kind, body) : mt) : CST.implication =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_exprorterm (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_in_expr ((kind, body) : mt) : CST.in_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_primary (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_instance_of ((kind, body) : mt) : CST.instance_of =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_typeexpr (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_mul_expr ((kind, body) : mt) : CST.mul_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            trans_mulop (Run.matcher_token v1),
            trans_exprorterm (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_negation ((kind, body) : mt) : CST.negation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exprorterm (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_orderby ((kind, body) : mt) : CST.orderby =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_exprorterm (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_direction (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_orderbys ((kind, body) : mt) : CST.orderbys =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_orderby (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_orderby (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_par_expr ((kind, body) : mt) : CST.par_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LPAR_simp_semg_meta_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_simpleid (Run.matcher_token v1),
                  trans_semgrep_metavariable (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `LPAR_expr_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_exprorterm (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_prefix_cast ((kind, body) : mt) : CST.prefix_cast =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_typeexpr (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_exprorterm (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary ((kind, body) : mt) : CST.primary =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Semg_ellips_meta (
            trans_semgrep_ellipsis_metavar (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Call_or_unqual_agg_expr (
            trans_call_or_unqual_agg_expr (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Qual_expr (
            trans_qualified_expr (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Lit (
            trans_literal (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Var (
            trans_variable (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Super_ref (
            trans_super_ref (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Aggr (
            trans_aggregate (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Range (
            trans_range (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Set_lit (
            trans_set_literal (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Par_expr (
            trans_par_expr (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Expr_anno (
            trans_expr_annotation (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_qualified_expr ((kind, body) : mt) : CST.qualified_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_primary (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_qualifiedrhs (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_qualifiedrhs ((kind, body) : mt) : CST.qualifiedrhs =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pred_opt_clos_LPAR_opt_call_arg_rep_COMMA_call_arg_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_predicatename (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_closure (Run.matcher_token v))
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_call_arg (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_call_arg (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `LPAR_type_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_typeexpr (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quantified ((kind, body) : mt) : CST.quantified =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_quantifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Opt_vard_rep_COMMA_vard_opt_BAR_expr_opt_BAR_expr (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_vardecl (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_vardecl (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                          v0
                        ,
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_exprorterm (Run.matcher_token v1),
                                  Run.opt
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_exprorterm (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v2
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Expr (
                  trans_exprorterm (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_range ((kind, body) : mt) : CST.range =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exprorterm (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_exprorterm (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_set_literal ((kind, body) : mt) : CST.set_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_exprorterm (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_exprorterm (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expr ((kind, body) : mt) : CST.unary_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_unop (Run.matcher_token v0),
            trans_exprorterm (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unqual_agg_body ((kind, body) : mt) : CST.unqual_agg_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_vardecl (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_vardecl (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_exprorterm (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_asexprs (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_importdirective ((kind, body) : mt) : CST.importdirective =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_importmoduleexpr (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_modulename (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_select ((kind, body) : mt) : CST.select =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_vardecl (Run.matcher_token v0),
                                Run.repeat
                                  (fun v ->
                                    (match v with
                                    | Seq [v0; v1] ->
                                        (
                                          Run.trans_token (Run.matcher_token v0),
                                          trans_vardecl (Run.matcher_token v1)
                                        )
                                    | _ -> assert false
                                    )
                                  )
                                  v1
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_exprorterm (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_asexprs (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_orderbys (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_body ((kind, body) : mt) : CST.body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exprorterm (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_higherorderterm ((kind, body) : mt) : CST.higherorderterm =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_literalid (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_predicateexpr (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_predicateexpr (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_call_arg (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_call_arg (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v6
            ,
            Run.trans_token (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semgrep_expression ((kind, body) : mt) : CST.semgrep_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exprorterm (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_charpred ((kind, body) : mt) : CST.charpred =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            trans_classname (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_exprorterm (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_datatypebranch ((kind, body) : mt) : CST.datatypebranch =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v -> trans_qldoc (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_annotation (Run.matcher_token v))
              v1
            ,
            trans_classname (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_vardecl (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_vardecl (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.trans_token (Run.matcher_token v5),
            Run.opt
              (fun v -> trans_body (Run.matcher_token v))
              v6
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_optbody ((kind, body) : mt) : CST.optbody =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Empty (
            trans_empty (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Body (
            trans_body (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `High (
            trans_higherorderterm (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_datatypebranches ((kind, body) : mt) : CST.datatypebranches =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_datatypebranch (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_datatypebranch (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_classlesspredicate ((kind, body) : mt) : CST.classlesspredicate =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Pred (
                  trans_predicate (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type (
                  trans_typeexpr (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_predicatename (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `LPAR_opt_vard_rep_COMMA_vard_RPAR_optb (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_vardecl (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_vardecl (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        Run.trans_token (Run.matcher_token v2),
                        trans_optbody (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Pred (
                  trans_predicatealiasbody (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_memberpredicate ((kind, body) : mt) : CST.memberpredicate =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Pred (
                  trans_predicate (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type (
                  trans_typeexpr (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_predicatename (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_vardecl (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_vardecl (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            trans_optbody (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_datatype ((kind, body) : mt) : CST.datatype =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_classname (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_datatypebranches (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_classmember ((kind, body) : mt) : CST.classmember =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Rep_anno_choice_char (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.repeat
                    (fun v -> trans_annotation (Run.matcher_token v))
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Char (
                        trans_charpred (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Memb (
                        trans_memberpredicate (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Field (
                        trans_field (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Qldoc (
            trans_qldoc (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_dataclass ((kind, body) : mt) : CST.dataclass =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_classname (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Opt_extends_type_rep_COMMA_type_opt_inst_type_rep_COMMA_type_choice_LCURL_rep_clas_RCURL (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_typeexpr (Run.matcher_token v1),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_typeexpr (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v2
                                )
                            | _ -> assert false
                            )
                          )
                          v0
                        ,
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_typeexpr (Run.matcher_token v1),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_typeexpr (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v2
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        (match v2 with
                        | Alt (0, v) ->
                            `LCURL_rep_clas_RCURL (
                              (match v with
                              | Seq [v0; v1; v2] ->
                                  (
                                    Run.trans_token (Run.matcher_token v0),
                                    Run.repeat
                                      (fun v -> trans_classmember (Run.matcher_token v))
                                      v1
                                    ,
                                    Run.trans_token (Run.matcher_token v2)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (1, v) ->
                            `SEMI (
                              Run.trans_token (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Type_e6aca0c (
                  trans_typealiasbody (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Type_9cc1977 (
                  trans_typeunionbody (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_module_ ((kind, body) : mt) : CST.module_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_modulename (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_moduleparam (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_moduleparam (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.trans_token (Run.matcher_token v3)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_signatureexpr (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_signatureexpr (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            (match v4 with
            | Alt (0, v) ->
                `LCURL_rep_modu_RCURL (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.repeat
                          (fun v -> trans_modulemember (Run.matcher_token v))
                          v1
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Modu (
                  trans_modulealiasbody (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_modulemember ((kind, body) : mt) : CST.modulemember =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Rep_anno_choice_impo (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.repeat
                    (fun v -> trans_annotation (Run.matcher_token v))
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Impo (
                        trans_importdirective (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Clas (
                        trans_classlesspredicate (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Data_cb44f91 (
                        trans_dataclass (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `Data_3931108 (
                        trans_datatype (Run.matcher_token v)
                      )
                  | Alt (4, v) ->
                      `Select (
                        trans_select (Run.matcher_token v)
                      )
                  | Alt (5, v) ->
                      `Module (
                        trans_module_ (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Qldoc (
            trans_qldoc (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_ql ((kind, body) : mt) : CST.ql =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_exp (
            trans_semgrep_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Rep_modu (
            Run.repeat
              (fun v -> trans_modulemember (Run.matcher_token v))
              v
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_ql matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

